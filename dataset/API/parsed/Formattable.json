{"name": "Interface Formattable", "module": "java.base", "package": "java.util", "text": "The Formattable interface must be implemented by any class that\n needs to perform custom formatting using the 's' conversion\n specifier of Formatter.  This interface allows basic\n control for formatting arbitrary objects.\n\n For example, the following class prints out different representations of a\n stock's name depending on the flags and length constraints:\n\n  \n   import java.nio.CharBuffer;\n   import java.util.Formatter;\n   import java.util.Formattable;\n   import java.util.Locale;\n   import static java.util.FormattableFlags.*;\n\n   ...\n\n   public class StockName implements Formattable {\n       private String symbol, companyName, frenchCompanyName;\n       public StockName(String symbol, String companyName,\n                        String frenchCompanyName) {\n           ...\n       }\n\n       ...\n\n       public void formatTo(Formatter fmt, int f, int width, int precision) {\n           StringBuilder sb = new StringBuilder();\n\n           // decide form of name\n           String name = companyName;\n           if (fmt.locale().equals(Locale.FRANCE))\n               name = frenchCompanyName;\n           boolean alternate = (f & ALTERNATE) == ALTERNATE;\n           boolean usesymbol = alternate || (precision != -1 && precision < 10);\n           String out = (usesymbol ? symbol : name);\n\n           // apply precision\n           if (precision == -1 || out.length() < precision) {\n               // write it all\n               sb.append(out);\n           } else {\n               sb.append(out.substring(0, precision - 1)).append('*');\n           }\n\n           // apply width and justification\n           int len = sb.length();\n           if (len < width)\n               for (int i = 0; i < width - len; i++)\n                   if ((f & LEFT_JUSTIFY) == LEFT_JUSTIFY)\n                       sb.append(' ');\n                   else\n                       sb.insert(0, ' ');\n\n           fmt.format(sb.toString());\n       }\n\n       public String toString() {\n           return String.format(\"%s - %s\", symbol, companyName);\n       }\n   }\n \n When used in conjunction with the Formatter, the above\n class produces the following output for various format strings.\n\n  \n   Formatter fmt = new Formatter();\n   StockName sn = new StockName(\"HUGE\", \"Huge Fruit, Inc.\",\n                                \"Fruit Titanesque, Inc.\");\n   fmt.format(\"%s\", sn);                   //   -> \"Huge Fruit, Inc.\"\n   fmt.format(\"%s\", sn.toString());        //   -> \"HUGE - Huge Fruit, Inc.\"\n   fmt.format(\"%#s\", sn);                  //   -> \"HUGE\"\n   fmt.format(\"%-10.8s\", sn);              //   -> \"HUGE      \"\n   fmt.format(\"%.12s\", sn);                //   -> \"Huge Fruit,*\"\n   fmt.format(Locale.FRANCE, \"%25s\", sn);  //   -> \"   Fruit Titanesque, Inc.\"\n \n Formattables are not necessarily safe for multithreaded access.  Thread\n safety is optional and may be enforced by classes that extend and implement\n this interface.\n\n  Unless otherwise specified, passing a null argument to\n any method in this interface will cause a NullPointerException to be thrown.", "codes": ["public interface Formattable"], "fields": [], "methods": [{"method_name": "formatTo", "method_sig": "void formatTo (Formatter formatter,\n              int flags,\n              int width,\n              int precision)", "description": "Formats the object using the provided formatter."}]}